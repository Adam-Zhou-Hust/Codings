// 复杂链表的赋值
// 复杂链表的节点结构比一般的链表多了一个指针域(类似二叉树的节点)，但是节点的额外指针
// 要么指向链表中的其他任意节点或者NULL
// 所以主体上看，仍然是链状结构
// 很显然的一个暴力解法
// 根据原始链表，先复制这个链表(先仅考虑next指针)，把新链表建立起来
// 在考虑填充新链表的节点的sibling指针
// 对于新链表的每个节点的sibling指针，我们要先根据原始的链表的相应节点的sibling指针
// 计算从原始节点到原始sibling节点的步数，再据此填充新节点的sibling域
// 综合来看，时间复杂度就达到了O(n2)
// 显然，不是一个非常好的算法

// 进一步思考，关键是在寻找原始sibling在新链表中的sibling的位置时候，要遍历链表
// 时间复杂度达到O(n)，如果O(1)时间获取sibling位置，则复杂度降低为O(n)
// 如果在创建新节点时，利用hash结构保留原节点和新节点的映射关系，那么就可以直接获取sibling指针

// 第三种方法则比较难一下子思考到
// 不过解决问题的基本方法仍然是基于在寻找sibling上做文章
// 前一种的思路在于保存了映射关系，但是以空间换时间，O(n)的空间复杂度
// 如果不使用额外空间，则使用另一种方法安排
// 让新复制的节点直接接在原始节点的后面
// 从而新节点的sibling就是原始节点的sibling节点的next节点
// 最后我们把链表分离

// 针对后两种思路的代码如下

#include <iostream>
